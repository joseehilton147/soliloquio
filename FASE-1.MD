  ğŸ—ï¸ Arquitetura Proposta - Fase 1 (Tarot)

  Estrutura Recomendada

  soliloquio/
  â”œâ”€â”€ apps/
  â”‚   â”œâ”€â”€ web/              # Portal/Hub - interliga todos os apps
  â”‚   â”œâ”€â”€ tarot/            # App do Tarot (Next.js 15)
  â”‚   â””â”€â”€ api/              # API centralizada (Next.js API Routes)
  â”‚
  â”œâ”€â”€ packages/
  â”‚   â”œâ”€â”€ ui/               # âœ… Componentes shadcn (jÃ¡ existe)
  â”‚   â”œâ”€â”€ database/         # ğŸ†• Prisma + schemas + migrations
  â”‚   â”œâ”€â”€ core/             # ğŸ†• Tipos, validaÃ§Ãµes (Zod), regras de negÃ³cio
  â”‚   â””â”€â”€ config/           # âœ… ESLint/TS configs (jÃ¡ existe)

  Por que essa estrutura?

  1. SeparaÃ§Ã£o de Concerns (MÃ­nima, nÃ£o over-engineering):
  - packages/database - Ãšnica fonte de verdade dos dados
  - packages/core - Tipos TypeScript compartilhados entre API e frontends
  - apps/api - Endpoints REST ou tRPC (recomendo tRPC para type-safety)
  - apps/tarot - Interface do usuÃ¡rio focada em Tarot
  - apps/web - Portal que conecta todos os apps (links, navegaÃ§Ã£o)

  2. Escalabilidade para Mobile:
  - API separada permite consumir de qualquer cliente (React Native, Expo)
  - packages/core compartilha validaÃ§Ãµes entre web e mobile
  - Quando criar mobile: sÃ³ adicionar apps/mobile usando mesmo backend

  3. EvoluÃ§Ã£o Natural (sem over-engineering inicial):

  Fase 1: Tarot
    â”œâ”€â”€ packages/database + core
    â”œâ”€â”€ apps/api
    â””â”€â”€ apps/tarot

  Fase 2: DiÃ¡rio/GrimÃ³rio
    â””â”€â”€ apps/grimorio (reutiliza database/core/api)

  Fase 3: Estudos
    â”œâ”€â”€ apps/umbanda
    â””â”€â”€ apps/espiritismo

  Fase 4: Mobile
    â””â”€â”€ apps/mobile (Expo/React Native)

  ğŸ¯ Stack Recomendada (MÃ­nima NecessÃ¡ria)

  | Camada    | Tecnologia           | Por quÃª?
  |
  |-----------|----------------------|--------------------------------------------------------------------
  |
  | Database  | Prisma + SQLite      | SQLite local para comeÃ§ar, migra para PostgreSQL depois sem cÃ³digo
  |
  | API       | tRPC v11             | Type-safe de ponta a ponta, sem duplicaÃ§Ã£o de tipos
  |
  | ValidaÃ§Ã£o | Zod                  | JÃ¡ estÃ¡ no projeto, integra com Prisma e tRPC
  |
  | State     | TanStack Query v5    | Cache, refetch, otimista - padrÃ£o da indÃºstria
  |
  | UI        | shadcn/ui + Tailwind | JÃ¡ configurado, design system consistente
  |

  Sobre o Objeto da Carta

  Seu JSON estÃ¡ excelente! Alguns ajustes tÃ©cnicos:

  // Seu objeto (com hÃ­fens)
  {
    "vertical-meaning": ["..."],
    "inverted-meaning": ["..."],
    "types-of-reading": [...]
  }

  // RecomendaÃ§Ã£o TypeScript (camelCase)
  {
    "verticalMeaning": ["..."],
    "invertedMeaning": ["..."],
    "typesOfReading": [...]
  }

  Estrutura de Tipos Proposta:

  // packages/core/src/tarot/card.schema.ts
  import { z } from 'zod';

  export const readingTypeSchema = z.object({
    type: z.enum(['general', 'love-relationship', 'career-money', 'personal-spiritual', 'inverted']),
    read: z.string(),
  });

  export const tarotCardSchema = z.object({
    id: z.string().uuid().optional(), // Gerado pelo banco
    name: z.string(),
    summary: z.string(),
    description: z.string(),
    verticalMeaning: z.array(z.string()),
    invertedMeaning: z.array(z.string()),
    numerology: z.string(),
    astrology: z.string().optional(),
    typesOfReading: z.array(readingTypeSchema),
    createdAt: z.date().optional(),
    updatedAt: z.date().optional(),
  });

  export type TarotCard = z.infer<typeof tarotCardSchema>;
  export type ReadingType = z.infer<typeof readingTypeSchema>;

  ğŸ—„ï¸ Schema do Prisma (Database)

  // packages/database/prisma/schema.prisma

  model TarotCard {
    id               String         @id @default(uuid())
    name             String         @unique
    summary          String
    description      String
    verticalMeaning  String[]       // Array de strings
    invertedMeaning  String[]
    numerology       String
    astrology        String?
    typesOfReading   ReadingType[]  // RelaÃ§Ã£o 1:N
    createdAt        DateTime       @default(now())
    updatedAt        DateTime       @updatedAt
  }

  model ReadingType {
    id        String     @id @default(uuid())
    type      String     // 'general', 'love-relationship', etc
    read      String     @db.Text
    cardId    String
    card      TarotCard  @relation(fields: [cardId], references: [id], onDelete: Cascade)
  }

  ğŸš€ Plano de ImplementaÃ§Ã£o - Fase 1

  Ordem TÃ©cnica LÃ³gica (sem estimativas de tempo):

  1. Criar packages/database
    - Inicializar Prisma
    - Criar schema das cartas
    - Criar migration inicial
    - Seed com "O Mago" (seu objeto)
  2. Criar packages/core
    - Schemas Zod das cartas
    - Tipos TypeScript exportados
    - UtilitÃ¡rios de validaÃ§Ã£o
  3. Criar apps/api
    - Setup tRPC v11
    - Routers: tarot.getAll, tarot.getById, tarot.create
    - Integrar com Prisma
  4. Criar apps/tarot
    - Setup Next.js 15
    - tRPC client configurado
    - PÃ¡ginas: / (lista), /cartas/[id] (detalhe)
    - Componentes: CardGrid, CardDetail
  5. Atualizar apps/web
    - Portal com links para /tarot
    - NavegaÃ§Ã£o entre apps

  ğŸ’¡ DecisÃµes Arquiteturais

  Por que tRPC e nÃ£o REST puro?

  | Aspecto       | REST                     | tRPC                          |
  |---------------|--------------------------|-------------------------------|
  | Type-safety   | âŒ Duplicar tipos         | âœ… Compartilha automaticamente |
  | ValidaÃ§Ã£o     | âš ï¸ Manual (Zod separado) | âœ… Zod integrado               |
  | Docs          | âš ï¸ Precisa Swagger       | âœ… Autocomplete no editor      |
  | Mobile futuro | âœ… PadrÃ£o universal       | âš ï¸ Precisa adapter (existe)   |

  RecomendaÃ§Ã£o: ComeÃ§ar com tRPC. Se mobile precisar de GraphQL/REST, adicionar camada depois.

  Por que SQLite â†’ PostgreSQL?

  - Agora: SQLite = zero configuraÃ§Ã£o, arquivo local, perfeito para desenvolvimento
  - Depois: PostgreSQL = produÃ§Ã£o, Supabase/Vercel Postgres, mesma API Prisma (sÃ³ trocar connection
  string)

  Por que apps separados (/tarot, /web)?

  - Isolamento: Cada app tem bundle, rotas, deploy independente
  - Performance: NÃ£o carrega cÃ³digo do GrimÃ³rio quando usar Tarot
  - Mobile: API jÃ¡ estÃ¡ separada, fÃ¡cil consumir
  - Escalabilidade: Time pode trabalhar em apps diferentes sem conflito

  ğŸ¨ Fluxo de Dados Proposto

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  apps/web   â”‚  â† Portal/Hub (links para apps)
  â”‚  (Next.js)  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ apps/tarot  â”‚â”€â”€â”€â”€â–¶â”‚   apps/api   â”‚â”€â”€â”€â”€â–¶â”‚ packages/       â”‚
  â”‚  (Next.js)  â”‚     â”‚    (tRPC)    â”‚     â”‚  database       â”‚
  â”‚             â”‚â—€â”€â”€â”€â”€â”‚              â”‚â—€â”€â”€â”€â”€â”‚  (Prisma)       â”‚
  â”‚  - UI       â”‚     â”‚  - Routers   â”‚     â”‚                 â”‚
  â”‚  - TanStack â”‚     â”‚  - Auth      â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚    Query    â”‚     â”‚  - ValidaÃ§Ã£o â”‚     â”‚  â”‚ SQLite    â”‚  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
         â”‚                   â”‚              â”‚                 â”‚
         â”‚                   â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
          â”‚  packages/  â”‚
          â”‚    core     â”‚
          â”‚             â”‚
          â”‚  - Tipos    â”‚
          â”‚  - Schemas  â”‚
          â”‚  - Utils    â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  âš ï¸ O que NÃƒO fazer agora (evitar over-engineering)

  âŒ MicroserviÃ§os separados (Tarot API, GrimÃ³rio API...)
  âŒ GraphQL Federation
  âŒ AutenticaÃ§Ã£o complexa (Auth0, Clerk) - deixar para depois
  âŒ Testes E2E completos - comeÃ§ar com alguns unitÃ¡rios
  âŒ CI/CD complexo - comeÃ§ar simples
  âŒ Docker/Kubernetes - desenvolvimento local primeiro
  âŒ MÃºltiplos bancos de dados